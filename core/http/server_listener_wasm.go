//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package http

import (
	"bufio"
	"log/slog"
	"net/http"
	"time"

	"tgp/core/net"
	"tgp/core/wasm"
)

// ListenerServeStart запускает HTTP сервер асинхронно через listener.Serve.
// Неблокирующая функция - возвращает управление сразу после запуска.
// Аналогично ListenerServeStart в internal/wasm/exports/net/listener.go.
// Возвращает listenerID, который можно использовать для остановки сервера через StopListenerByID.
func ListenerServeStart(addr string, handler http.Handler) (listenerID uint64, err error) {

	// Создаём listener
	listener, err := net.Listen(net.NetworkTCP, addr)
	if err != nil {
		slog.Error("ListenerServeStart: failed to create listener", "error", err)
		return 0, err
	}

	listenerID = listener.ID()

	// Устанавливаем connectionHandler для обработки новых соединений для этого listener
	// connectionHandler будет вызываться для каждого нового соединения через callback on_new_connection
	// ВАЖНО: callback on_new_connection вызывается через CallChannel на хосте, что гарантирует:
	// 1. Все соединения принимаются на хосте в цикле Accept() (параллельно)
	// 2. Обработка соединений в WASM происходит последовательно через CallChannel
	// 3. Однопоточность вызовов WASM гарантируется CallChannel
	net.SetConnectionHandler(listenerID, func(connID uint64) {

		// Создаём Conn из connID
		conn := net.NewConnFromID(connID)

		// Обрабатываем HTTP соединение напрямую
		// ВАЖНО: Это выполняется внутри callback'а on_new_connection, который уже вызван через CallChannel
		// CallChannel гарантирует последовательность обработки всех соединений
		defer func() {
			// Обрабатываем панику, если она произошла
			if r := recover(); r != nil {
				slog.Error("ListenerServeStart: panic recovered", "listenerID", listenerID, "connID", connID, "panic", r)
			}
			if closeErr := conn.Close(); closeErr != nil {
				slog.Error("ListenerServeStart: failed to close connection", "listenerID", listenerID, "connID", connID, "error", closeErr)
			}
		}()

		// Создаём буферизованный reader для чтения HTTP запроса
		reader := bufio.NewReader(conn)

		// Читаем HTTP запрос из соединения
		var req *http.Request
		if req, err = http.ReadRequest(reader); err != nil {
			slog.Error("ListenerServeStart: failed to read HTTP request", "listenerID", listenerID, "connID", connID, "error", err)
			return
		}

		// Устанавливаем RemoteAddr для запроса
		if req.RemoteAddr == "" {
			if remoteAddr := conn.RemoteAddr(); remoteAddr != nil {
				req.RemoteAddr = remoteAddr.String()
			}
		}

		// Создаём ResponseWriter для записи ответа
		writer := bufio.NewWriter(conn)
		respWriter := &responseWriter{
			conn:   conn,
			writer: writer,
			header: make(http.Header),
		}

		// Обрабатываем запрос через handler
		handler.ServeHTTP(respWriter, req)

		// Финализируем ответ (отправляем заголовки, если ещё не отправлены)
		if respWriter.statusCode == 0 {
			respWriter.WriteHeader(http.StatusOK)
		}

		// Флушим буфер, чтобы убедиться, что все данные отправлены
		if flushErr := writer.Flush(); flushErr != nil {
			slog.Error("ListenerServeStart: failed to flush response", "listenerID", listenerID, "connID", connID, "error", flushErr)
		}

		// ВАЖНО: Ждем, пока все данные будут прочитаны хостом из кольцевого буфера перед закрытием соединения
		// Это необходимо, так как bufio.Writer.Flush() только записывает данные в conn.Write(),
		// но данные могут еще не успеть передаться через кольцевой буфер на хост
		// Проверяем, что буфер записи пуст (ReadIndex == WriteIndex), что означает, что все данные прочитаны
		writeBufferPtr, getBufferErr := conn.GetWriteBufferPtr()
		if getBufferErr == nil {
			// Ждем, пока буфер записи не станет пустым (все данные прочитаны хостом)
			// Используем таймаут, чтобы не ждать бесконечно
			maxWaitTime := time.Second * 5
			checkInterval := time.Millisecond * 5
			startTime := time.Now()
			var isEmpty bool
			for time.Since(startTime) < maxWaitTime {
				if isEmpty, getBufferErr = wasm.IsWriteBufferEmpty(writeBufferPtr); getBufferErr != nil {
					break
				}
				if isEmpty {
					// Буфер пуст, все данные прочитаны
					break
				}
				// Буфер еще не пуст, ждем немного
				time.Sleep(checkInterval)
			}
			// Если буфер не пуст после таймаута, это не критично - соединение все равно закроется
		}
	})

	// Запускаем listener через Serve (асинхронно)
	// listener.Serve запускает цикл Accept() на хосте и вызывает callback on_new_connection для каждого соединения
	if serveErr := listener.Serve("on_new_connection"); serveErr != nil {
		slog.Error("ListenerServeStart: failed to start listener serve", "error", serveErr)
		// Удаляем handler при ошибке
		net.RemoveConnectionHandler(listenerID)
		return 0, serveErr
	}
	return
}
